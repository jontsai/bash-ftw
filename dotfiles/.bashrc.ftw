#!/bin/bash
#
# .bashrc.ftw
# author: Jonathan Tsai <hello@jontsai.com>
#
# An opinionated .bashrc file
#

# don't execute if not an interactive BASH shell
# `$-` shows `i` if an interactive shell
[[ ${-#*i} != ${-} ]] || return

# Enable START/STOP output control (XON/XOFF flow control)
# https://superuser.com/questions/159106/reverse-i-search-in-bash
stty -ixon


################################################################################
# Bash Session Meta


# determine the Kernel type
KERNEL=`uname -s`

function determine_bashrc {
    if [ $KERNEL == 'Darwin' ] && [ -f $HOME/.bash_profile ]
    then
        BASHRC_FILE=$HOME/.bash_profile
    elif [ -f $HOME/.bash_aliases ]
    then
        BASHRC_FILE=$HOME/.bash_aliases
elif [ -f $HOME/.bashrc ]
    then
        BASHRC_FILE=$HOME/.bashrc
    else
        BASHRC_FILE=''
    fi
}
determine_bashrc

if [[ ${BASHFTW} == 1 ]]
then
    echo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    echo bash-ftw has already been loaded, not reloading.
    echo It may be included twice in your bashrc file, ${BASHRC_FILE}
    echo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    return
else
    # set sentinel value to prevent double load
    BASHFTW=1

    echo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    echo ">>>>>> Loading bash-ftw <<<<<<"
fi

function rebash {
    # force reload
    BASHFTW=0

    determine_bashrc

    # reloads ~/.bashrc, ~/.bash_aliases, or ~/.bash_profile

    if [[ $BASHRC_FILE ]]
    then
        echo "Reloading ${BASHRC_FILE}"
        source $BASHRC_FILE
    fi
}


################################################################################
# BASH globals


# http://en.wikipedia.org/wiki/Umask
umask 0002


################################################################################
# BASH functions


function parse_git_branch {
    if [[ ! -z $1 ]] && [[ $1 == '-p' ]]
    then
        SHOW_PARENS=1
        shift
    fi

    TEST_GIT_REPO=`git rev-parse 2> /dev/null > /dev/null`
    if [[ $? ]]
    then
        CURRENT_GIT_BRANCH=`git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/'`
    else
        CURRENT_GIT_BRANCH=''
    fi

    if [[ ${CURRENT_GIT_BRANCH} ]]
    then
        if [[ ${SHOW_PARENS} ]]
        then
            echo "(${CURRENT_GIT_BRANCH})"
        else
            echo "${CURRENT_GIT_BRANCH}"
        fi
    fi

    unset SHOW_PARENS
}

function grep-kill {
    PATTERN=$1
    ps -A | grep ${PATTERN} | grep -v grep | awk '{print $1}' | xargs kill
}

function kill-port() {
    # Courtesy of: https://github.com/Justintime50
    # See `man kill` for allowed kill signals
    PORT=$1
    SIGNAL=$2
    SUDO=$3

    SIGNAL_ARG=""
    PIDS=($($SUDO lsof -t -i:$PORT | sed -e ':a' -e 'N' -e '$!ba' -e 's/\n/ /g'))

    if [[ ! -z $SIGNAL ]]
    then
        if [[ "-1 -HUP -2 -INT -3 -QUIT -6 -ABRT -9 -KILL -14 -ALRM -15 -TERM" =~ $SIGNAL ]]
        then
            SIGNAL_ARG=${SIGNAL}
        else
            echo "Unknown kill signal: ${SIGNAL}"
        fi
    fi

    if [ "$PIDS" ]
    then
        for pid in "${PIDS[@]}"; do
            echo "Killing process $pid..."
            echo ${SUDO} kill ${SIGNAL_ARG} ${pid}
            ${SUDO} kill ${SIGNAL_ARG} ${pid}
        done
    else
        echo "No process running on port ${PORT}"
    fi
}

function settitle {
    echo -ne "\e]0;$1\a"
}


##
# Node.js
function n {
   $(npm bin)/$@
}

################################################################################
# Prompt
#
# \d - Current date
# \t - Current time
# \h - Host name
# \# - Command number
# \u - User name
# \W - Current working directory (ie: Desktop/)
# \w - Current working directory, full path (ie: /Users/Admin/Desktop)
#
# Color codes:
# - https://unix.stackexchange.com/questions/124407/what-color-codes-can-i-use-in-my-ps1-prompt
# - https://misc.flogisoft.com/bash/tip_colors_and_formatting
#
# Default Mac Style: PS1="\h:\W \u$"
# Ubuntu Style: export PS1="\u@\h:\w$ "
#
export PS1="\[\033[01;90m\][\t] \[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[01;36m\]\$(parse_git_branch -p)\[\033[01;34m\]\$\[\033[00m\] "


################################################################################
# exports


# local scripts and /usr/local/bin, /usr/local/sbin
PATH=$HOME/bin:$HOME/.local/bin:$PATH:/usr/local/sbin:/usr/local/bin

# Go: Set default GOPATH and add GOPATH/bin to PATH for tools installed via `go install`
# (e.g., goimports, golint, etc.)
export GOPATH="${GOPATH:-$HOME/go}"
PATH="$PATH:$GOPATH/bin"

# Bun: JavaScript runtime & toolkit
export BUN_INSTALL="$HOME/.bun"
export PATH="$BUN_INSTALL/bin:$PATH"

export PATH

# Emacs is the best:
# https://andreyorst.gitlab.io/posts/2020-04-29-text-editors/
export SVN_EDITOR=emacs
export EDITOR=emacs

# GPG
export GPG_TTY=$(tty)

# RipGrep is better than `ag`:
# - https://github.com/BurntSushi/ripgrep
# - https://github.com/ggreer/the_silver_searcher
export SEARCH_UTIL=rg

export HISTTIMEFORMAT="%Y-%m-%d %T "

export CLICOLOR=1
export CLICOLOR_FORCE=1

# https://docs.python.org/2/using/cmdline.html#envvar-PYTHONDONTWRITEBYTECODE
# Disable writing of Python bytecode (*.pyc files) -- negligible performance issue in dev
export PYTHONDONTWRITEBYTECODE=1

export TMPDIR=/tmp


################################################################################
# aliases


##
# basic commands
alias ..='cd ..'
alias ..2='cd ../..'
alias ..3='cd ../../..'
alias ..4='cd ../../../..'
alias ..5='cd ../../../../..'
alias ..6='cd ../../../../../..'
alias c='cd'
alias l='ls -CF'
alias la='ls -aF'
alias ll='ls -lhF'
alias lla='ls -lahF'
alias llt='ls -lhtF'
alias llat='ls -lahtF'
alias pu='pushd'
alias po='popd'
alias rm='rm -i'
alias cp='cp -i'
alias grep='grep --color=always'
alias lessr='less -R'
alias morer='more -R'
alias retmux='tmux source-file ~/.tmux.conf'
alias show-functions='declare -F'

# common typos
alias cd..='cd ..'

##
# GPG
alias gpgl='gpg --list-secret-keys --keyid-format=long'
alias gpg-export-pubkey='gpg --armor --export'
alias gpg-export-secret='gpg --export-secret-keys --armor'
alias gpg-gen='gpg --full-generate-key'
alias gpg-restart='gpgconf --kill all'
alias gpg-test='echo "test" | gpg --clearsign'

##
# dev
alias edithosts='sudo emacs /etc/hosts'
alias rmemacsbackups='for FILE in `find . -name "*~"`; do rm -i $FILE; done'
alias svns='svn status'

##
# Python helpers
alias ipy='ipython'
alias rmpyc='for FILE in `find . -name "*.pyc"`; do rm -i $FILE; done'
alias vipy='venv/bin/ipython'
alias vpip='venv/bin/pip'
alias vpy='venv/bin/python'
alias vpytest='venv/bin/pytest'

##
# Emacs helpers
alias rmelc='for FILE in `find . -name "*.elc"`; do rm -i $FILE; done'

##
# Git

export GIT_DEFAULT_BRANCH
: "${GIT_DEFAULT_BRANCH:=master}"


alias gb='git branch'
alias gbr='git branch -r'  # list Git branches on remote
alias gca='git commit -a'
alias gcam='git commit --amend'
alias gcb='git create-branch'
alias gcd='git checkout develop'
alias gcm='git checkout ${GIT_DEFAULT_BRANCH}'
alias gco='git checkout'
alias gcp='git checkout gh-pages'
alias gdsf='git dsf'
alias glog='git log'
alias gpfwl='git push --force-with-lease'
alias gpl='git pull'
alias gpu='git push'
alias gpuuo='parse_git_branch | xargs git push -u origin'  # push new branch and set origin remote as upstream
alias groi='git rebase -i origin/${GIT_DEFAULT_BRANCH}'
alias gsq='git-squash'
alias gst='git status'
alias git-last-raw='git log -1 --format="commit %H%nAuthor: %an <%ae>%nDate:   %ad%n%n%B"'
alias gitup='export GIT_TMP_BRANCH=`git rev-parse --abbrev-ref HEAD | tr -d "\n"`; git checkout ${GIT_DEFAULT_BRANCH}; git fetch origin; git rebase origin/${GIT_DEFAULT_BRANCH}; git checkout ${GIT_TMP_BRANCH}'
alias gitdeletemerged='git branch --merged ${GIT_DEFAULT_BRANCH} | grep -v "${GIT_DEFAULT_BRANCH}$" | xargs git branch -d'


# sync all Git repository subdirectories within current directory
function gsa {
    cwd=`pwd`
    echo "Syncing all Git repository subdirectories within $cwd"

    # strip color codes from `ls`
    # See: https://stackoverflow.com/questions/17998978/removing-colors-from-output
    for dir in `ls | sed $'s,\x1b\\[[0-9;]*[a-zA-Z],,g'`
    do
        fulldir="${cwd}/${dir}"

        if [[ -d $fulldir ]]
        then
            echo -e "--------------------\n"
            echo -e "Going in to $fulldir\n"
            cd $fulldir
            echo -e "Fetching latest code from origin...\n"
            git fetch origin
            echo -e "Updating ${GIT_DEFAULT_BRANCH}...\n"
            git co ${GIT_DEFAULT_BRANCH} && git merge origin/${GIT_DEFAULT_BRANCH}
            #git gc
        else
            echo "Skipping $fulldir"
        fi
    done

    cd $cwd
}

# create a new Git branch tracking remote branch
function gcob {
    git checkout -B $1 origin/$1
}

function gitdeletenonmaster {
    for branch in `git branch | awk '{ print $1}' | grep -v '^*'`; do if [[ "$branch" != "master" && "$branch" != "main" ]]; then git branch -D $branch; fi; done
}


function git-squash {
    NUM_COMMITS=$@;
    re='^[0-9]+$'
    if ! [[ $NUM_COMMITS =~ $re ]]
    then
        echo 'Error: git-squash expects a number of commits to squash'
    else
        git reset --soft HEAD~${NUM_COMMITS} && git commit --edit -m"$(git log --format=%B --reverse HEAD..HEAD@{1})"
    fi
}

function git-ls-changed {
    git status --porcelain | grep M | awk '{print $2}'
}

function git-delete-tag {
    # delete tag locally
    git tag -d $1
    # delete tag in all remotes
    for remote in $(git remote)
    do
        git push $remote :refs/tags/$1
    done
}

function git-rename-branch {
    # renames the local branch and on ALL remotes
    git branch -m $1 $2
    for remote in $(git remote)
    do
        git push $remote -u $2
        git push $remote --delete $1
    done
}


################################################################################
# Git Worktrees
#
# The .worktrees Standard:
#   ~/code/
#   ├── project-a/              # main worktree (unchanged)
#   ├── project-b/              # main worktree (unchanged)
#   └── .worktrees/             # hidden directory for ALL project worktrees
#       ├── project-a/
#       │   ├── feature-x/
#       │   └── bugfix-y/
#       └── project-b/
#           └── refactor-z/
#

# Base directory for all code (override in .bashrc.$USER if needed)
CODE_DIR="${CODE_DIR:-$HOME/code}"
WORKTREES_DIR="$CODE_DIR/.worktrees"

# Protected branches that shouldn't have worktrees (override in .bashrc.$USER if needed)
GWT_PROTECTED_BRANCHES="${GWT_PROTECTED_BRANCHES:-main master develop development staging release}"

# Helper: detect project name from current directory
function _gwt_detect_project {
    local dir="$PWD"

    # Check if we're in a worktree directory
    if [[ "$dir" == "$WORKTREES_DIR/"* ]]; then
        # Extract project name: $WORKTREES_DIR/<project>/...
        local rel="${dir#$WORKTREES_DIR/}"
        echo "${rel%%/*}"
        return 0
    fi

    # Check if we're in a main repo directory
    if [[ "$dir" == "$CODE_DIR/"* ]]; then
        local rel="${dir#$CODE_DIR/}"
        # Skip hidden directories (like .worktrees itself)
        if [[ "$rel" != .* ]]; then
            echo "${rel%%/*}"
            return 0
        fi
    fi

    return 1
}

# Helper: check if a branch is protected
function _gwt_is_protected_branch {
    local branch=$1
    local protected

    for protected in $GWT_PROTECTED_BRANCHES; do
        if [[ "$branch" == "$protected" ]]; then
            return 0
        fi
    done
    return 1
}

# Helper: detect current worktree name (returns empty if in main repo)
function _gwt_detect_worktree {
    local dir="$PWD"

    # Only works if we're in a worktree directory
    if [[ "$dir" == "$WORKTREES_DIR/"* ]]; then
        # Extract worktree name: $WORKTREES_DIR/<project>/<worktree>/...
        local rel="${dir#$WORKTREES_DIR/}"
        local after_project="${rel#*/}"
        echo "${after_project%%/*}"
        return 0
    fi

    return 1
}

# cd into a worktree (or main repo if no worktree specified)
function gwt {
    local detected=$(_gwt_detect_project)

    # No args: if inside project, go to main repo
    if [[ $# -eq 0 ]]; then
        if [[ -n "$detected" ]]; then
            cd "$CODE_DIR/$detected"
        else
            echo "Usage: gwt [project] [worktree-name]"
            echo "       (project auto-detected when inside a worktree directory)"
            return 1
        fi
        return
    fi

    # One arg: could be worktree (if inside project) or project name
    if [[ $# -eq 1 ]]; then
        if [[ -n "$detected" ]]; then
            # Inside project - check if arg is a worktree name
            if [[ -d "$WORKTREES_DIR/$detected/$1" ]]; then
                cd "$WORKTREES_DIR/$detected/$1"
                return
            fi
        fi
        # Treat as project name, go to main repo
        cd "$CODE_DIR/$1"
        return
    fi

    # Two args: explicit project and worktree
    cd "$WORKTREES_DIR/$1/$2"
}

# cd to a worktree (auto-detects project from current directory)
function gwt-cd {
    local detected=$(_gwt_detect_project)

    if [[ $# -eq 0 ]]; then
        echo "Usage: gwt-cd [project] <worktree>"
        echo "       (project auto-detected when inside a worktree directory)"
        return 1
    fi

    local project name

    if [[ $# -eq 1 ]]; then
        if [[ -n "$detected" ]]; then
            project=$detected
            name=$1
        else
            echo "Error: Not inside a project. Specify project explicitly."
            echo "Usage: gwt-cd <project> <worktree>"
            return 1
        fi
    else
        project=$1
        name=$2
    fi

    if [[ ! -d "$WORKTREES_DIR/$project/$name" ]]; then
        echo "Error: Worktree '$name' not found for project '$project'"
        return 1
    fi

    cd "$WORKTREES_DIR/$project/$name"
}

# Create a worktree (auto-detects if branch exists or needs to be created)
function gwt-mk {
    local force=false
    if [[ "$1" == "--force" || "$1" == "-f" ]]; then
        force=true
        shift
    fi

    local project branch base

    # Auto-detect project if inside a worktree-enabled directory
    local detected=$(_gwt_detect_project)
    if [[ -n "$detected" && $# -le 2 ]]; then
        # Inside project: gwt-mk <branch> [base]
        project=$detected
        branch=$1
        base=${2:-${GIT_DEFAULT_BRANCH}}
    else
        # Outside project: gwt-mk <project> <branch> [base]
        project=$1
        branch=$2
        base=${3:-${GIT_DEFAULT_BRANCH}}
    fi

    if [[ -z "$project" || -z "$branch" ]]; then
        echo "Usage: gwt-mk [--force] [project] <branch> [base-branch]"
        echo "       (project auto-detected when inside a worktree directory)"
        echo "       If branch exists, creates worktree for it"
        echo "       If branch doesn't exist, creates new branch from base-branch"
        return 1
    fi

    if [[ "$force" == false ]] && _gwt_is_protected_branch "$branch"; then
        echo "Warning: '$branch' is a protected branch. Creating worktrees for it is unusual."
        echo "Use 'gwt-mk --force $branch' to override."
        echo "(Configure with GWT_PROTECTED_BRANCHES variable)"
        return 1
    fi

    mkdir -p "$WORKTREES_DIR/$project"

    # Check if branch exists locally or remotely
    if git -C "$CODE_DIR/$project" show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null || \
       git -C "$CODE_DIR/$project" show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
        # Branch exists - create worktree for it
        git -C "$CODE_DIR/$project" worktree add "$WORKTREES_DIR/$project/$branch" "$branch"
    else
        # Branch doesn't exist - create new branch from base
        git -C "$CODE_DIR/$project" worktree add -b "$branch" "$WORKTREES_DIR/$project/$branch" "$base"
    fi
}

# List all worktrees for a project (auto-detects from current directory)
function gwt-ls {
    local project=${1:-$(_gwt_detect_project)}

    if [[ -z "$project" ]]; then
        echo "Usage: gwt-ls [project]"
        echo ""
        echo "All projects with worktrees:"
        ls -1 "$WORKTREES_DIR" 2>/dev/null || echo "No worktrees yet."
        return
    fi

    # Get worktree list and highlight current directory
    local current_path="$PWD"
    git -C "$CODE_DIR/$project" worktree list | while IFS= read -r line; do
        # Extract the path (first field)
        local wt_path="${line%% *}"
        if [[ "$current_path" == "$wt_path"* ]]; then
            echo "* $line"
        else
            echo "  $line"
        fi
    done
}

# Remove a worktree (auto-detects project from current directory)
function gwt-rm {
    local project name

    # No args: if inside a worktree, offer to remove it
    if [[ $# -eq 0 ]]; then
        project=$(_gwt_detect_project)
        name=$(_gwt_detect_worktree)

        if [[ -z "$name" ]]; then
            echo "Usage: gwt-rm [project] [name]"
            echo "       (run with no args inside a worktree to remove it)"
            return 1
        fi

        # Confirm before removing current worktree
        echo "Remove worktree '$name' from project '$project'? [y/N] "
        read -r confirm
        if [[ "$confirm" != "y" && "$confirm" != "Y" ]]; then
            echo "Cancelled."
            return 0
        fi

        # cd out of worktree before removing
        cd "$CODE_DIR/$project"
    elif [[ $# -eq 1 ]]; then
        # One arg: try to auto-detect project
        project=$(_gwt_detect_project)
        name=$1
    else
        # Two args: explicit project and name
        project=$1
        name=$2
    fi

    if [[ -z "$project" || -z "$name" ]]; then
        echo "Usage: gwt-rm [project] [name]"
        echo "       (project auto-detected when inside a worktree directory)"
        return 1
    fi

    git -C "$CODE_DIR/$project" worktree remove "$WORKTREES_DIR/$project/$name"

    # Clean up empty project directory
    rmdir "$WORKTREES_DIR/$project" 2>/dev/null
}

# Prune stale worktree references (auto-detects project from current directory)
function gwt-prune {
    local project=${1:-$(_gwt_detect_project)}

    if [[ -z "$project" ]]; then
        echo "Usage: gwt-prune [project]"
        echo "       (project auto-detected when inside a worktree directory)"
        return 1
    fi

    git -C "$CODE_DIR/$project" worktree prune
}

# Bash completion for gwt commands

# Helper: get current word from COMP_LINE (handles slashes in branch names)
function _gwt_get_cur {
    local line="${COMP_LINE:0:COMP_POINT}"
    # Get last word, not splitting on /
    echo "${line##* }"
}

function _gwt_complete_projects {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    # List directories in CODE_DIR (excluding hidden dirs like .worktrees)
    local projects=$(ls -1 --color=never "$CODE_DIR" 2>/dev/null | grep --color=never -v '^\.')
    COMPREPLY=($(compgen -W "$projects" -- "$cur"))
}

function _gwt_complete_worktrees {
    local project=$1
    local cur=$(_gwt_get_cur)
    # Use git worktree list to get actual worktree names (handles slashes in names)
    local worktrees=$(git --no-pager -C "$CODE_DIR/$project" worktree list --porcelain 2>/dev/null | \
        grep --color=never "^worktree " | \
        sed "s|^worktree ||" | \
        sed "s|^$WORKTREES_DIR/$project/||" | \
        grep --color=never -v "^$CODE_DIR")
    COMPREPLY=($(compgen -W "$worktrees" -- "$cur"))
}

function _gwt_complete_branches {
    local project=$1
    local cur=$(_gwt_get_cur)
    if [[ -d "$CODE_DIR/$project/.git" || -d "$CODE_DIR/$project" ]]; then
        local branches=$(git --no-pager -C "$CODE_DIR/$project" branch -a --no-color --format='%(refname:short)' 2>/dev/null | \
            sed 's|origin/||' | sort -u)
        COMPREPLY=($(compgen -W "$branches" -- "$cur"))
    fi
}

function _gwt_completion {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    local detected=$(_gwt_detect_project)

    if [[ -n "$detected" ]]; then
        # Inside project - first arg is worktree name
        case $COMP_CWORD in
            1) _gwt_complete_worktrees "$detected" ;;
        esac
    else
        # Outside project - first arg is project, second is worktree
        case $COMP_CWORD in
            1) _gwt_complete_projects ;;
            2) _gwt_complete_worktrees "$prev" ;;
        esac
    fi
}

function _gwt_mk_completion {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Handle --force flag
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W "--force -f" -- "$cur"))
        return
    fi

    # Determine position accounting for --force/-f
    local pos=$COMP_CWORD
    if [[ "${COMP_WORDS[1]}" == "--force" || "${COMP_WORDS[1]}" == "-f" ]]; then
        ((pos--))
    fi

    # Check if inside a project directory
    local detected=$(_gwt_detect_project)

    if [[ -n "$detected" ]]; then
        # Inside project - first arg is branch
        case $pos in
            1) _gwt_complete_branches "$detected" "$cur" ;;
        esac
    else
        # Outside project - first arg is project, second is branch
        case $pos in
            1) _gwt_complete_projects ;;
            2)
                local project="${COMP_WORDS[COMP_CWORD-1]}"
                if [[ "${COMP_WORDS[1]}" == "--force" || "${COMP_WORDS[1]}" == "-f" ]]; then
                    project="${COMP_WORDS[2]}"
                fi
                _gwt_complete_branches "$project" "$cur"
                ;;
        esac
    fi
}

function _gwt_rm_completion {
    local cur=$(_gwt_get_cur)
    local prev="${COMP_WORDS[COMP_CWORD-1]}"

    case $COMP_CWORD in
        1)
            # Could be project or worktree name if inside project dir
            local detected=$(_gwt_detect_project)
            if [[ -n "$detected" ]]; then
                # Offer both projects and worktrees of current project
                _gwt_complete_projects
                local worktrees=$(git --no-pager -C "$CODE_DIR/$detected" worktree list --porcelain 2>/dev/null | \
                    grep --color=never "^worktree " | \
                    sed "s|^worktree ||" | \
                    sed "s|^$WORKTREES_DIR/$detected/||" | \
                    grep --color=never -v "^$CODE_DIR")
                COMPREPLY+=($(compgen -W "$worktrees" -- "$cur"))
            else
                _gwt_complete_projects
            fi
            ;;
        2) _gwt_complete_worktrees "$prev" ;;
    esac
}

function _gwt_ls_prune_completion {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    if [[ $COMP_CWORD -eq 1 ]]; then
        _gwt_complete_projects
    fi
}

function _gwt_cd_completion {
    local cur="${COMP_WORDS[COMP_CWORD]}"
    local prev="${COMP_WORDS[COMP_CWORD-1]}"
    local detected=$(_gwt_detect_project)

    if [[ -n "$detected" ]]; then
        # Inside project - first arg is worktree
        case $COMP_CWORD in
            1) _gwt_complete_worktrees "$detected" ;;
        esac
    else
        # Outside project - first arg is project, second is worktree
        case $COMP_CWORD in
            1) _gwt_complete_projects ;;
            2) _gwt_complete_worktrees "$prev" ;;
        esac
    fi
}

# Register completions
complete -F _gwt_completion gwt
complete -F _gwt_cd_completion gwt-cd
complete -F _gwt_mk_completion gwt-mk
complete -F _gwt_ls_prune_completion gwt-ls
complete -F _gwt_rm_completion gwt-rm
complete -F _gwt_ls_prune_completion gwt-prune


##
# Text Processing & File Utilities


function edit-matching-files {
    QUERY=${1}
    if [[ -z $QUERY ]]
    then
        echo 'No query entered'
    else
        $EDITOR $(${SEARCH_UTIL} "${1}" | cut -d : -f 1 | sort | uniq)
    fi
}


function dsf {
    F1=$1
    F2=$2
    diff -u ${F1} ${F2} | diff-so-fancy
}


function get-packages {
    # Read from STDIN and process package names
    # Removes comments (lines starting with #), empty lines, and trims whitespace
    # Usage: cat package-file.txt | get-packages
    # or: get-packages < package-file.txt
    sed '/^#/ d; s/#.*$//; s/^[[:space:]]*//; s/[[:space:]]*$//' | grep -v '^$'
}


##
# MySQL


function tailmysql {
    sudo mysql -e "SET GLOBAL general_log = 'ON';"
    sudo less +F $(mysql -Nse "SELECT @@general_log_file")
    sudo mysql -e "SET GLOBAL general_log = 'OFF';"
}


##
# TMUX
alias tma='tmux attach -t'
alias tmkill='tmux kill-session -t'
alias tmls='tmux ls'
alias tmnew='tmux new -s'

##
# utils
alias jq='jq -C'
alias json='python -mjson.tool'
alias keyup='. ssh-agent-init;ssh-keychain-init'

echo 'Auto-initializing SSH Agent...'
if [ `command -v ssh-agent-init` ]
then
    . ssh-agent-init
else
    echo 'ssh-agent-init command not defined... skipped'
fi

##
# Docker
alias dcdu='docker-compose down --remove-orphans;docker-compose up -d'

##
# Hacktoolkit (https://github.com/hacktoolkit)
# See also: http://github.com/hacktoolkit/python-htk
alias fdb='touch /tmp/fdebug.log; tail -f /tmp/fdebug.log'

##
# Internet / Networking

ECHO_IP_URL='ifconfig.co'
alias check-ip="curl ${ECHO_IP_URL}"
alias check-ipv4="curl -4 ${ECHO_IP_URL}"
alias check-ipv6="curl -6 ${ECHO_IP_URL}"
alias check-proxy-ip="curl -x socks5h://localhost:1080 ${ECHO_IP_URL}"
alias check-proxy-ipv4="curl -4 -x socks5h://localhost:1080 ${ECHO_IP_URL}"
alias check-proxy-ipv6="curl -6 -x socks5h://localhost:1080 ${ECHO_IP_URL}"

##
# Haste

haste() { a=$(cat); curl -X POST -s -d "$a" https://haste.l33t.xyz/documents | awk -F '"' '{print "https://haste.l33t.xyz/"$4}'; }


################################################################################
# directories


alias bin='cd ~/bin'
alias code='cd ~/code'
alias dload='cd ~/dload'
alias temp='cd ~/tmp'
alias www='cd ~/www'


################################################################################
# rbenv
# https://github.com/rbenv/rbenv#installation

if [ -d "$HOME/.rbenv/bin" ]
then
    export PATH="$HOME/.rbenv/bin:$PATH"
elif [ -x "/opt/homebrew/bin/rbenv" ]
then
    export PATH="/opt/homebrew/bin/:$PATH"
fi



if [ command -v rbenv > /dev/null 2>&1 ] || [[ -n `which rbenv` ]]
then
    echo 'Setting rbenv...'
    eval "$(rbenv init -)"
else
    echo 'rbenv not found... skipping'
fi


################################################################################
# Installation Cheatsheets


alias install-bun="curl -fsSL https://bun.sh/install | bash"
alias install-claude="curl -fsSL https://claude.ai/install.sh | bash"
alias install-cursor="curl https://cursor.com/install -fsS | bash"
alias install-nvm="curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash"
alias install-pip="curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py"
alias install-rust="curl https://sh.rustup.rs -sSf | sh"
alias install-tpm="git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm"

# GitHub CLI installation
function install-gh {
    if [[ $KERNEL == 'Darwin' ]]; then
        echo "Installing GitHub CLI via Homebrew..."
        brew install gh
    elif [[ $KERNEL == 'Linux' ]]; then
        echo "Installing GitHub CLI via apt..."
        curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
        && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
        && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
        && sudo apt update \
        && sudo apt install gh -y
    else
        echo "Unsupported OS: $KERNEL"
        echo "Visit https://cli.github.com for installation instructions"
        return 1
    fi

    echo ""
    echo "GitHub CLI installed successfully!"
    echo "Run 'gh auth login' to authenticate"
}


################################################################################
# source other .bashrc files


# Linux
[[ $KERNEL == 'Linux' ]] && [[ -s "$HOME/.bashrc.ftw.linux" ]] && source "$HOME/.bashrc.ftw.linux"

# Mac
[[ $KERNEL == 'Darwin' ]] && [[ -s "$HOME/.bashrc.ftw.mac" ]] && source "$HOME/.bashrc.ftw.mac"

# User .bashrc
[[ -s "$HOME/.bashrc.$USER" ]] && source "$HOME/.bashrc.$USER"

# Bash completion support for Git. Based on https://github.com/git/git/blob/master/contrib/completion/git-completion.bash
[[ -s "$HOME/.git-completion.bash" ]] && source "$HOME/.git-completion.bash"

# Load various .bashrc.* customizations
# Define BASHRC_GROUPS as an export in the .bashrc.$USER file
for group in ${BASHRC_GROUPS}
do
    BASHRC_FILE="$HOME/.bashrc.${group}"
    [[ -s $BASHRC_FILE ]] && source ${BASHRC_FILE}
done


################################################################################
# Load direnv if installed
# https://github.com/direnv/direnv


if [[ -s `which direnv` ]]
then
    eval "$(direnv hook bash)"
else
    echo 'direnv not found... skipping'
fi


################################################################################
# THE END

echo ">>>>>> Finished loading bash-ftw <<<<<<"
echo ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
